<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chroma Key Feature Test Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #4fc3f7;
            margin-bottom: 20px;
            text-align: center;
        }
        .test-section {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #3a3a3a;
        }
        .test-section h2 {
            color: #81c784;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .test-item {
            padding: 10px;
            margin: 5px 0;
            background: #333;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .test-item.passed {
            border-left: 4px solid #4caf50;
        }
        .test-item.failed {
            border-left: 4px solid #f44336;
        }
        .test-item.pending {
            border-left: 4px solid #ff9800;
        }
        .test-name {
            flex: 1;
        }
        .test-status {
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
        }
        .status-passed {
            background: #4caf50;
            color: white;
        }
        .status-failed {
            background: #f44336;
            color: white;
        }
        .status-pending {
            background: #ff9800;
            color: white;
        }
        .test-details {
            margin-top: 10px;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 4px;
            font-size: 12px;
            color: #aaa;
            display: none;
        }
        .test-item.expanded .test-details {
            display: block;
        }
        .summary {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        }
        .summary-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }
        .stat {
            padding: 15px;
            background: #333;
            border-radius: 4px;
            min-width: 120px;
        }
        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #4fc3f7;
        }
        .stat-label {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
        button {
            background: #4fc3f7;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover {
            background: #29b6f6;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        iframe {
            width: 100%;
            height: 600px;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            background: #000;
        }
        .log {
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .log-entry {
            padding: 2px 0;
        }
        .log-entry.info {
            color: #4fc3f7;
        }
        .log-entry.success {
            color: #4caf50;
        }
        .log-entry.error {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Chroma Key Feature Test Suite</h1>
        
        <div class="controls">
            <button id="startTestBtn">‚ñ∂Ô∏è Start Tests</button>
            <button id="stopTestBtn" disabled>‚èπÔ∏è Stop Tests</button>
            <button id="clearLogBtn">üóëÔ∏è Clear Log</button>
        </div>

        <div class="test-section">
            <h2>üìπ Video Loading & Controls</h2>
            <div id="videoTests"></div>
        </div>

        <div class="test-section">
            <h2>üé® Color Detection Features</h2>
            <div id="colorTests"></div>
        </div>

        <div class="test-section">
            <h2>‚öôÔ∏è Settings & Sliders</h2>
            <div id="settingsTests"></div>
        </div>

        <div class="test-section">
            <h2>üì§ Export Functions</h2>
            <div id="exportTests"></div>
        </div>

        <div class="test-section">
            <h2>üñ±Ô∏è UI Interactions</h2>
            <div id="uiTests"></div>
        </div>

        <div class="summary">
            <h2>Test Summary</h2>
            <div class="summary-stats">
                <div class="stat">
                    <div class="stat-value" id="totalTests">0</div>
                    <div class="stat-label">Total Tests</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="passedTests">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="failedTests">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="pendingTests">0</div>
                    <div class="stat-label">Pending</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>üìã Test Log</h2>
            <div id="testLog" class="log"></div>
        </div>

        <div class="test-section">
            <h2>üñºÔ∏è Test Page (iframe)</h2>
            <iframe id="testFrame" src="index.html"></iframe>
        </div>
    </div>

    <script>
        const TEST_VIDEO_URL = 'https://brizi-sandbox-bucket.s3.us-east-1.amazonaws.com/video_export_20260119_102951.webm';
        
        let testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            pending: 0
        };
        
        let testFrame = null;
        let isRunning = false;
        let testTimeout = null;

        // Initialize
        window.addEventListener('load', () => {
            testFrame = document.getElementById('testFrame');
            testFrame.addEventListener('load', () => {
                log('Test page loaded', 'info');
            });
        });

        function log(message, type = 'info') {
            const logDiv = document.getElementById('testLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[TEST] ${message}`);
        }

        function addTest(sectionId, name, testFn) {
            const section = document.getElementById(sectionId);
            const testItem = document.createElement('div');
            testItem.className = 'test-item pending';
            testItem.innerHTML = `
                <span class="test-name">${name}</span>
                <span class="test-status status-pending">PENDING</span>
                <div class="test-details"></div>
            `;
            section.appendChild(testItem);
            
            testResults.total++;
            testResults.pending++;
            updateSummary();
            
            return {
                pass: (details = '') => {
                    testItem.className = 'test-item passed';
                    testItem.querySelector('.test-status').className = 'test-status status-passed';
                    testItem.querySelector('.test-status').textContent = 'PASSED';
                    if (details) {
                        testItem.querySelector('.test-details').textContent = details;
                        testItem.addEventListener('click', () => {
                            testItem.classList.toggle('expanded');
                        });
                    }
                    testResults.pending--;
                    testResults.passed++;
                    updateSummary();
                    log(`‚úÖ ${name}: PASSED${details ? ' - ' + details : ''}`, 'success');
                },
                fail: (error = '') => {
                    testItem.className = 'test-item failed';
                    testItem.querySelector('.test-status').className = 'test-status status-failed';
                    testItem.querySelector('.test-status').textContent = 'FAILED';
                    if (error) {
                        testItem.querySelector('.test-details').textContent = error;
                        testItem.addEventListener('click', () => {
                            testItem.classList.toggle('expanded');
                        });
                    }
                    testResults.pending--;
                    testResults.failed++;
                    updateSummary();
                    log(`‚ùå ${name}: FAILED${error ? ' - ' + error : ''}`, 'error');
                }
            };
        }

        function updateSummary() {
            document.getElementById('totalTests').textContent = testResults.total;
            document.getElementById('passedTests').textContent = testResults.passed;
            document.getElementById('failedTests').textContent = testResults.failed;
            document.getElementById('pendingTests').textContent = testResults.pending;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function waitForElement(frame, selector, timeout = 10000) {
            const start = Date.now();
            while (Date.now() - start < timeout) {
                try {
                    const element = frame.contentDocument.querySelector(selector);
                    if (element) return element;
                } catch (e) {
                    // Cross-origin or not ready
                }
                await sleep(100);
            }
            throw new Error(`Element ${selector} not found within ${timeout}ms`);
        }

        async function waitForVideoReady(frame, timeout = 30000) {
            const start = Date.now();
            while (Date.now() - start < timeout) {
                try {
                    const video = frame.contentWindow.video;
                    if (video && video.readyState >= 2 && video.duration > 0) {
                        return video;
                    }
                } catch (e) {
                    // Not accessible yet
                }
                await sleep(100);
            }
            throw new Error('Video not ready within timeout');
        }

        async function loadVideoInFrame(frame, url) {
            try {
                // Fetch the video and create a blob URL
                const response = await fetch(url);
                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);
                
                // Set video source directly
                if (frame.contentWindow.video) {
                    frame.contentWindow.video.src = blobUrl;
                    frame.contentWindow.video.load();
                    await sleep(2000);
                    return true;
                }
                return false;
            } catch (e) {
                log(`Error loading video: ${e.message}`, 'error');
                return false;
            }
        }

        async function runTests() {
            if (isRunning) return;
            isRunning = true;
            document.getElementById('startTestBtn').disabled = true;
            document.getElementById('stopTestBtn').disabled = false;
            
            log('Starting test suite...', 'info');
            
            try {
                const frame = testFrame.contentWindow;
                const doc = testFrame.contentDocument;
                
                // Wait for page to be ready
                await sleep(2000);
                
                // ========== VIDEO LOADING & CONTROLS ==========
                log('Testing video loading and controls...', 'info');
                
                // Test 1: Load video from URL
                const test1 = addTest('videoTests', 'Load video from S3 URL');
                try {
                    log('Loading test video...', 'info');
                    const loaded = await loadVideoInFrame(testFrame, TEST_VIDEO_URL);
                    if (!loaded) {
                        test1.fail('Could not load video');
                        return;
                    }
                    
                    await sleep(2000);
                    const video = await waitForVideoReady(testFrame, 15000);
                    if (video && video.duration > 0) {
                        test1.pass(`Video loaded: ${video.duration.toFixed(2)}s, ${video.videoWidth}x${video.videoHeight}`);
                    } else {
                        test1.fail('Video did not load properly');
                    }
                } catch (e) {
                    test1.fail(e.message);
                }
                
                // Test 2: Play/Pause button
                const test2 = addTest('videoTests', 'Play/Pause button');
                try {
                    const playBtn = await waitForElement(testFrame, '#playPauseBtn');
                    const video = await waitForVideoReady(testFrame);
                    
                    // Test play
                    const wasPaused = video.paused;
                    playBtn.click();
                    await sleep(500);
                    if (wasPaused && !video.paused) {
                        test2.pass('Play button works');
                    } else {
                        test2.fail('Play button did not start playback');
                    }
                } catch (e) {
                    test2.fail(e.message);
                }
                
                // Test 3: Seek bar
                const test3 = addTest('videoTests', 'Seek bar functionality');
                try {
                    const seekBar = await waitForElement(testFrame, '#seekBar');
                    const video = await waitForVideoReady(testFrame);
                    
                    const initialTime = video.currentTime;
                    seekBar.value = 50;
                    seekBar.dispatchEvent(new Event('input'));
                    await sleep(500);
                    
                    const newTime = video.currentTime;
                    if (Math.abs(newTime - (video.duration * 0.5)) < 1) {
                        test3.pass(`Seeked to ${newTime.toFixed(2)}s`);
                    } else {
                        test3.fail(`Expected ~${(video.duration * 0.5).toFixed(2)}s, got ${newTime.toFixed(2)}s`);
                    }
                } catch (e) {
                    test3.fail(e.message);
                }
                
                // Test 4: Repeat button
                const test4 = addTest('videoTests', 'Repeat/Loop button');
                try {
                    const repeatBtn = await waitForElement(testFrame, '#repeatBtn');
                    const video = await waitForVideoReady(testFrame);
                    
                    repeatBtn.click();
                    await sleep(300);
                    const isLooping = video.loop;
                    repeatBtn.click();
                    await sleep(300);
                    const notLooping = !video.loop;
                    
                    if (isLooping && notLooping) {
                        test4.pass('Repeat toggle works');
                    } else {
                        test4.fail('Repeat toggle not working correctly');
                    }
                } catch (e) {
                    test4.fail(e.message);
                }
                
                // Test 5: Mute button
                const test5 = addTest('videoTests', 'Mute/Unmute button');
                try {
                    const muteBtn = await waitForElement(testFrame, '#muteBtn');
                    const video = await waitForVideoReady(testFrame);
                    
                    const wasMuted = video.muted;
                    muteBtn.click();
                    await sleep(300);
                    const isMuted = video.muted;
                    
                    if (wasMuted !== isMuted) {
                        test5.pass('Mute toggle works');
                    } else {
                        test5.fail('Mute toggle not working');
                    }
                } catch (e) {
                    test5.fail(e.message);
                }
                
                // ========== COLOR DETECTION FEATURES ==========
                log('Testing color detection features...', 'info');
                
                // Test 6: Green screen detection
                const test6 = addTest('colorTests', 'Green screen detection mode');
                try {
                    const enableGreen = await waitForElement(testFrame, '#enableGreen');
                    enableGreen.checked = true;
                    enableGreen.dispatchEvent(new Event('change'));
                    await sleep(500);
                    
                    if (enableGreen.checked && frame.enableGreenFilter) {
                        test6.pass('Green screen mode enabled');
                    } else {
                        test6.fail('Green screen mode not enabled');
                    }
                } catch (e) {
                    test6.fail(e.message);
                }
                
                // Test 7: Color picker
                const test7 = addTest('colorTests', 'Color picker button');
                try {
                    const colorPickerBtn = await waitForElement(testFrame, '#colorPickerBtn');
                    const enableCustom = await waitForElement(testFrame, '#enableCustom');
                    
                    enableCustom.checked = true;
                    enableCustom.dispatchEvent(new Event('change'));
                    await sleep(300);
                    
                    colorPickerBtn.click();
                    await sleep(300);
                    
                    if (frame.isPickerMode) {
                        test7.pass('Color picker mode activated');
                    } else {
                        test7.fail('Color picker mode not activated');
                    }
                } catch (e) {
                    test7.fail(e.message);
                }
                
                // Test 8: Region picker
                const test8 = addTest('colorTests', 'Region picker button');
                try {
                    const regionPickerBtn = await waitForElement(testFrame, '#regionPickerBtn');
                    const enableRegion = await waitForElement(testFrame, '#enableRegion');
                    
                    enableRegion.checked = true;
                    enableRegion.dispatchEvent(new Event('change'));
                    await sleep(300);
                    
                    regionPickerBtn.click();
                    await sleep(300);
                    
                    if (frame.isRegionPickerMode) {
                        test8.pass('Region picker mode activated');
                    } else {
                        test8.fail('Region picker mode not activated');
                    }
                } catch (e) {
                    test8.fail(e.message);
                }
                
                // Test 9: Reset filter
                const test9 = addTest('colorTests', 'Reset filter button');
                try {
                    const resetBtn = await waitForElement(testFrame, '#resetFilterBtn');
                    resetBtn.click();
                    await sleep(500);
                    test9.pass('Reset filter executed');
                } catch (e) {
                    test9.fail(e.message);
                }
                
                // ========== SETTINGS & SLIDERS ==========
                log('Testing settings and sliders...', 'info');
                
                // Test 10: Green screen threshold slider
                const test10 = addTest('settingsTests', 'Green screen threshold slider');
                try {
                    const thresholdSlider = await waitForElement(testFrame, '#threshold');
                    const initialValue = parseFloat(thresholdSlider.value);
                    thresholdSlider.value = '0.5';
                    thresholdSlider.dispatchEvent(new Event('input'));
                    await sleep(300);
                    
                    if (parseFloat(thresholdSlider.value) === 0.5) {
                        test10.pass('Threshold slider works');
                    } else {
                        test10.fail('Threshold slider not updating');
                    }
                } catch (e) {
                    test10.fail(e.message);
                }
                
                // Test 11: Smoothness slider
                const test11 = addTest('settingsTests', 'Smoothness slider');
                try {
                    const smoothnessSlider = await waitForElement(testFrame, '#smoothness');
                    smoothnessSlider.value = '2.0';
                    smoothnessSlider.dispatchEvent(new Event('input'));
                    await sleep(300);
                    
                    if (parseFloat(smoothnessSlider.value) === 2.0) {
                        test11.pass('Smoothness slider works');
                    } else {
                        test11.fail('Smoothness slider not updating');
                    }
                } catch (e) {
                    test11.fail(e.message);
                }
                
                // ========== EXPORT FUNCTIONS ==========
                log('Testing export functions...', 'info');
                
                // Test 12: Export button opens modal
                const test12 = addTest('exportTests', 'Export button opens modal');
                try {
                    const exportBtn = await waitForElement(testFrame, '#exportBtn');
                    const exportModal = await waitForElement(testFrame, '#exportModal');
                    
                    exportBtn.click();
                    await sleep(500);
                    
                    if (exportModal.classList.contains('active')) {
                        test12.pass('Export modal opens');
                    } else {
                        test12.fail('Export modal did not open');
                    }
                } catch (e) {
                    test12.fail(e.message);
                }
                
                // Test 13: Export format selection
                const test13 = addTest('exportTests', 'Export format selection');
                try {
                    const formatSelect = await waitForElement(testFrame, '#exportFormat');
                    const formats = ['frames', 'frames-png', 'webm', 'gif'];
                    
                    for (const format of formats) {
                        formatSelect.value = format;
                        formatSelect.dispatchEvent(new Event('change'));
                        await sleep(100);
                        if (formatSelect.value !== format) {
                            throw new Error(`Format ${format} not selectable`);
                        }
                    }
                    test13.pass(`All ${formats.length} formats selectable`);
                } catch (e) {
                    test13.fail(e.message);
                }
                
                // Test 14: FPS selection
                const test14 = addTest('exportTests', 'FPS selection');
                try {
                    const fpsSelect = await waitForElement(testFrame, '#exportFps');
                    const fpsOptions = ['10', '15', '24', '30', '60'];
                    
                    for (const fps of fpsOptions) {
                        fpsSelect.value = fps;
                        fpsSelect.dispatchEvent(new Event('change'));
                        await sleep(100);
                        if (fpsSelect.value !== fps) {
                            throw new Error(`FPS ${fps} not selectable`);
                        }
                    }
                    test14.pass(`All ${fpsOptions.length} FPS options selectable`);
                } catch (e) {
                    test14.fail(e.message);
                }
                
                // Test 15: Cancel export
                const test15 = addTest('exportTests', 'Cancel export button');
                try {
                    const cancelBtn = await waitForElement(testFrame, '#cancelExportBtn');
                    const exportModal = await waitForElement(testFrame, '#exportModal');
                    
                    // Ensure modal is open
                    if (!exportModal.classList.contains('active')) {
                        const exportBtn = await waitForElement(testFrame, '#exportBtn');
                        exportBtn.click();
                        await sleep(500);
                    }
                    
                    cancelBtn.click();
                    await sleep(300);
                    
                    if (!exportModal.classList.contains('active')) {
                        test15.pass('Cancel button closes modal');
                    } else {
                        test15.fail('Cancel button did not close modal');
                    }
                } catch (e) {
                    test15.fail(e.message);
                }
                
                // ========== UI INTERACTIONS ==========
                log('Testing UI interactions...', 'info');
                
                // Test 16: Settings visibility toggle
                const test16 = addTest('uiTests', 'Settings visibility toggle');
                try {
                    const enableGreen = await waitForElement(testFrame, '#enableGreen');
                    const defaultSettings = await waitForElement(testFrame, '#defaultSettings');
                    
                    enableGreen.checked = true;
                    enableGreen.dispatchEvent(new Event('change'));
                    await sleep(300);
                    
                    const isVisible = defaultSettings.style.display !== 'none' || 
                                     defaultSettings.classList.contains('active');
                    
                    if (isVisible) {
                        test16.pass('Settings panel shows when enabled');
                    } else {
                        test16.fail('Settings panel not visible');
                    }
                } catch (e) {
                    test16.fail(e.message);
                }
                
                // Test 17: Seek bar after video ends
                const test17 = addTest('uiTests', 'Seek bar works after video ends');
                try {
                    const seekBar = await waitForElement(testFrame, '#seekBar');
                    const video = await waitForVideoReady(testFrame);
                    const playBtn = await waitForElement(testFrame, '#playPauseBtn');
                    
                    // Play to end
                    video.currentTime = video.duration - 0.5;
                    playBtn.click();
                    await sleep(2000);
                    
                    // Try to seek
                    seekBar.value = 25;
                    seekBar.dispatchEvent(new Event('input'));
                    await sleep(500);
                    
                    if (video.currentTime < video.duration * 0.3) {
                        test17.pass('Seek bar works after video ends');
                    } else {
                        test17.fail('Seek bar did not work after video ended');
                    }
                } catch (e) {
                    test17.fail(e.message);
                }
                
                log('All tests completed!', 'success');
                
            } catch (error) {
                log(`Test suite error: ${error.message}`, 'error');
                console.error(error);
            } finally {
                isRunning = false;
                document.getElementById('startTestBtn').disabled = false;
                document.getElementById('stopTestBtn').disabled = true;
            }
        }

        // Event listeners
        document.getElementById('startTestBtn').addEventListener('click', runTests);
        document.getElementById('stopTestBtn').addEventListener('click', () => {
            isRunning = false;
            if (testTimeout) clearTimeout(testTimeout);
            document.getElementById('startTestBtn').disabled = false;
            document.getElementById('stopTestBtn').disabled = true;
            log('Tests stopped by user', 'info');
        });
        document.getElementById('clearLogBtn').addEventListener('click', () => {
            document.getElementById('testLog').innerHTML = '';
        });
    </script>
</body>
</html>
